# 쿠키와 세션 정리 (Frontend 관점)

## 1. 쿠키와 세션이 필요한 이유

웹은 기본적으로 **Stateless(무상태)** 구조입니다.  
즉, 각 요청은 이전 요청과 독립적으로 처리되며, 서버는 사용자의 상태를 자동으로 기억하지 않습니다.

하지만 실제 서비스에서는 다음과 같은 **상태 유지**가 필요합니다.

- 로그인 상태 유지
- 장바구니 정보 유지
- 사용자 설정 값 유지

이러한 상태를 관리하기 위해 대표적으로 **쿠키(Cookie)** 와 **세션(Session)** 이 사용됩니다.

---

## 2. 쿠키(Cookie)

### 개념
- **클라이언트(브라우저)에 저장되는 데이터**
- 서버가 응답 시 `Set-Cookie` 헤더로 전달
- 이후 클라이언트는 요청마다 쿠키를 **자동으로 포함**하여 서버로 전송

### 특징
- 브라우저에 저장됨
- 유효 기간(`Expires`, `Max-Age`) 설정 가능
- 서버는 별도의 상태 저장소를 유지하지 않아도 됨

### 장점
- 서버 자원을 사용하지 않음
- 지속적인 상태 유지 가능
- 구현이 비교적 단순

### 단점
- 클라이언트에 저장되므로 **탈취 위험**
- 민감한 정보 저장에 부적합
- 크기 제한 존재

### 보안 관련 옵션
- `HttpOnly` : JavaScript 접근 차단 → XSS 방어
- `Secure` : HTTPS 환경에서만 전송
- `SameSite` : CSRF 방어

---

## 3. 세션(Session)

### 개념
- **서버에 저장되는 사용자 상태 정보**
- 클라이언트에는 **세션 ID**만 전달
- 서버는 세션 ID를 기준으로 상태 조회

### 특징
- 실제 데이터는 서버에 저장
- 클라이언트는 세션 ID만 보유
- 일반적으로 세션 ID는 쿠키로 전달됨

### 장점
- 쿠키보다 **보안성 우수**
- 민감한 정보 서버 보관 가능
- 서버에서 상태 통제 가능

### 단점
- 서버 메모리/스토리지 사용
- 사용자 수 증가 시 서버 부하
- 분산 환경에서는 세션 동기화 필요

---

## 4. LocalStorage / SessionStorage와의 차이

### 공통점
- 브라우저에 데이터를 저장
- 쿠키와 유사한 클라이언트 저장 방식

### 차이점
- **자동으로 서버에 전송되지 않음**
- JavaScript로 직접 접근 가능
- XSS 공격에 취약

### 저장소별 특징
- `LocalStorage` : 브라우저 종료 후에도 유지
- `SessionStorage` : 탭 종료 시 삭제

### 인증에 부적합한 이유
- 자동 전송되지 않아 인증 처리에 추가 구현 필요
- XSS에 취약
- `HttpOnly` 옵션 사용 불가

➡️ **인증 상태 관리에는 일반적으로 쿠키 사용이 선호됨**

---

## 5. 로그인 구현 시 세션 방식을 사용하는 경우

### 주 사용 사례
- 보안 중요도가 높은 서비스
- 금융, 공공, 사내 시스템 등

### 적합한 이유
- 세션 ID만 노출 → 탈취 시 피해 최소화
- 서버에서 세션 무효화 가능

### 활용 예시
- 원격 로그아웃
- 강제 로그아웃
- 동시 로그인 기기 수 제한
- 특정 사용자 세션 즉시 차단

### 고려 사항
- 서버 자원 사용 증가
- 분산 시스템에서는 Redis 등 세션 스토어 필요
- 확장성과 비용 고려 필요

---

## 6. 정리

| 구분 | 쿠키 | 세션 |
|---|---|---|
| 저장 위치 | 클라이언트 | 서버 |
| 서버 자원 | 사용 안 함 | 사용 |
| 보안성 | 낮음 (보완 가능) | 높음 |
| 확장성 | 좋음 | 불리 |
| 자동 전송 | O | O (세션 ID) |

➡️ **서비스 특성, 보안 요구사항, 인프라 구조를 고려하여 트레이드오프 기반으로 선택하는 것이 중요**