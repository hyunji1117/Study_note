# 자바스크립트 딥 다이브

# 01장 프로그래밍

## 1-1. 프로그래밍 이란?

컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션

문제 요구사항 명확히 이해 ➡️ 적절한 문제 해결 방안 정의

> - 복잡함을 단순하게 분해
> - 자료 정리 및 구분
> - 순서에 맞게 행위 배열

컴퓨터의 입장에서 문제를 바라봐야 한다. (aka. 컴퓨팅 사고)

> 논리적, 수학적 사고 필요
> 해결 과제를 작은 단위로 분해
> 패턴화 하여 추출
> 모든 개념은 평가 가능하도록 정의


문제 해결 능력 : 

> 직감과 직관의 영역
> 이는 문제를 바라보는 사고와 경험에 영향을 받는다.


## 1-2. 프로그래밍 언어

사람이 이해할 수 있는 약속된 문구(syntax) 문법

일종의 번역기 (compiler / interpreter)
![alt text](/04_Assets/image-4.png)

자연어 : 
인간이 자연스럽게 발달시킨 언어 (예: 영어, 프랑스어)

인공어 : 
특정한 목적을 위해 인위적으로 만들어진 언어 (예: 에스페란토, Python)


## 1-3. 구문(syntax)과 의미(semantics)


---

# 02 자바스크립트란?

## 2-1. 자바스크립트의 탄생

1995년 넷스케이프 커뮤니케이션즈가 웹페이지의 보조적 기능을 수행하기 위해 Brendan Eich 브랜던 아이크가 만든 웹브라우저에서 동작하는 경량프로그래밍 언어 

## 2-2. 자바스크립트의 표준화

1996년 마이크로소프트가 만든 Javacript의 파생버전 Jscript를 익스플로러 3.0에 탑재

즉, 자사 브라우저에만 동작하는 기능 추가

크로스 브라우징 이슈 발생

Javascript 파편화 방지, 모든 사이트 동작 Javascript 표준화 대두

컴퓨터 시스템 표준 관리 비영리 표준화 기구 - ECMA 인터네셔널 - 표준화 요청


## 2-3. 자바스크립트 성장의 역사

렌더링(rendering) : 
HTML, CSS, JS 문서를 해석해서 브라우저에서 시각적으로 출력하는 것 의미

### 2-3-1. Ajax

1999년 Javascript를 이용해서 서버와 브라우저가 비동기 방식으로 데이터를 교환하는 통신 기능

### 2-3-2. jQuery

2006년 DOM 쉽게 제어, 크로스 브라우징 어느정도 해결
구글 맵스 활용

### 2-3-3. V8 자바스크립트 엔진

구글 맵스로 인해 Javascript로 웹 어플리케이션 구축 시도가 늘면서 Javascript의 엔진 필요성 대두

2008년 구글 V8 자바스크립트 엔진은 요구사항 부합하는 빠른 성능 보유

### 2-3-4. Node.js

2009년 Javascript 런타임 환경

브라우저 자바스크립트 엔진에서만 동작하던 Javascript를 브라우저 외 환경에서 독립시킨 자바스크립트 실행 환경

서버 사이드 어플리케이션에 주로 사용

SPA (single page application)에 적합

CPU 사용률이 높은 어플리케이션 사용 권장X

### 2-3-5. SPA 프레임워크

복잡해진 모던 웹 애플리케이션 개발의 어려움과 기존 개발 방식의 확장성 부족 문제를 해결하기 위해, 컴포넌트 기반 개발(CBD) 방법론을 활용한 SPA 프레임워크(Angular, React, Vue.js, Svelte 등)가 등장


## 2-4. 자바스크립트와 ECMAScript

ECMAScript는 자바스크립트의 표준 사양(ECMA-262)으로, 프로그래밍 언어의 핵심 기능과 브라우저가 지원하는 클라이언트 사이드 Web API(DOM, Canvas, fetch 등)를 통해 웹 개발을 가능하게 하는 언어


## 2-5. 자바스크립트의 특징

자바스크립트는 웹을 구성하는 유일한 프로그래밍 언어로, 컴파일 없이 실행되는 인터프리터 언어이며, 명령형/함수형/프로토타입 기반 객체지향을 모두 지원하는 멀티 패러다임 언어


## 2-6. ES6 브라우저 지원 현황



---

# 03 자바스크립트 개발환경과 실행 방법


## 3-1. 자바스크립트 실행 환경

Node.js는 브라우저 외부에서 JavaScript를 실행할 수 있는 런타임 환경을 제공하여, JavaScript로 서버 사이드 개발과 다양한 애플리케이션 개발을 가능하게 한다

>- Node.js는 실제로 브라우저와 동일한 V8 JavaScript 엔진을 사용합니다
>- 브라우저 외부(서버 사이드)에서 JavaScript를 실행할 수 있게 해줍니다
 Node.js를 사용하는 주된 이유는 단순히 "동일한 엔진 환경"을 만들기 위함이 아니라:
> 1. **풀스택 JavaScript 개발** - 프론트엔드와 백엔드를 같은 언어로 개발
> 2. **서버 사이드 개발** - 웹 서버, API 서버 구축
> 3. **개발 도구 생태계** - npm 패키지 관리, 빌드 도구 등
> 4. **비동기 I/O 처리** - 높은 동시성 처리 능력
> 5. **크로스 플랫폼 애플리케이션** - 데스크톱 앱, 모바일 앱 개발

웹 크롤링 : 
서버에서 웹사이트의 콘텐츠를 수집하기 위해 웹사이트에서 HTML 문서를 가지고 온 다음
가공해서 필요한 데이터만 추출하는 경우

## 3-2. 웹 브라우저

### 3-2-1. 개발자 도구

![alt text](/04_Assets/image-3.png)

### 3-2-2. 콘솔

```js
console.log // 메서드를 사용하여 결과를 콘솔에 출력하는 함수
```

자바스크립트 코드를 직접 입력해 그 결과를 확인할 수 있는 REPL(Read Eval Print Loop: 입력 수 행 출력 반복) 환경으로 사용 가능
![alt text](/04_Assets/image-2.png)

### 3-2-3. 브라우저에서 자바스크립트 실행

![alt text](/04_Assets/image-1.png)


### 3-2-4. 디버깅

에러 위치를 클릭하면 코드 디버깅할 수 있는 Source 패널로 이동하게 된다. 


## 3-3. Node.js

클라이언트 사이드 웹 애플리케이션은 브라우저에서만 동작하지만, 프로젝트 규모가 커지면서 React, Angular 등의 프레임워크와 Babel, Webpack 등의 개발 도구들을 사용하게 되었고, 이를 위해 Node.js와 npm이 필요

### 3-3-1. Node.js와 npm 소개

### 3-3-2. Node.js 설치

### 3-3-3. Node.js REPL


## 3-4. 비주얼 스튜디오 코드

### 3-4-1. 비주얼 스튜디오 코드 설치

### 3-4-2. 내장 터미널

### 3-4-3. Code Runner 확장 플러그인

### 3-4-4. Live Server 확장 플러그인

소스 코드를 수정할 때 마다 수정 사항을 브라우저에 자동으로 반영


---


# 04 변수

## 4-1. 변수란 무엇인가? 왜 필요한가?


```txt
10 + 20
```

10, 20,+라는 기호(리터럴eral과 연산자peralor)의 의미를 알고 있어야 하며, 10+ 20이라는 식(표현식expresion) 의 의미도 해석(파싱asing)할 수 있어야 한다. 

컴퓨터는 연산 과 기억을 수행하는 부품이 나눠져 있다.

CPU를 사용해 연산
메모리를 사용해 데이터를 기억

> 메모리(memory)는 데이터를 저장할 수 있는 메모리 셀(memory cell)의 집합
> 메모리 셀 하나의 크기는 1바이트(8 비트)
> 메모리 셀의 크기(1바이트 단위)로 데이터를 저장(write)하거나 읽어(read)들인다.

![alt text](/04_Assets/image-5.png)

위 예제의 숫자 값 10과 20은 메모리 상의 임의의 위치(메모리 주소)에 기억(저장)

CPU는 이 값을 읽어 들여 연산 수행

연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 위치에 저장

다음 그림에 는 메모리에 저장된 숫자 값을 편의상 10진수로 표기했다. 하지만 메모리에 저장되는 모든 값은 2진수로 저 장된다는 것

![alt text](/04_Assets/image-6.png)

만약 30을 재사용하고 싶다면

> 메모리 주소(0x0669F913)를 통해 값 30에 직접 접근할 수 있지만, 이는 치명적 오류를 발생시킬 수 있어 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

변수 : 
하나의 값을 저장하기 위해 확보한 메모리 공간 자체
그 메모리 공간을 식별하기 위해 붙 인 상징적인 이름

상징적 이름인 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간 주소로 치환되어 실행


## 4-2. 식별자

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름으로, 변수나 함수 등의 메모리 공간에 저장된 값에 접근하기 위해 사용하는 기호이다.

## 4-3. 변수 선언

변수 생성
값을 저장하기 위한 메모리 공간 확보하고, 변수 이름과 확보한 메모리 공간 연결하여 값 저장 준비

변수 사용하기 위해 반듯이 선언 필요

```txt
var, let, const 사용
```

# 4-4. 변수 선언의 실행 시점과 호이스팅 

자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행
변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조 가능

변수 선언이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행되는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)이라 하며, var, let, const, function 등 모든 식별자는 호이스팅된다.

## 4-5. 값의 할당

## 4-6. 값의 재할당

변수에 값을 재할당하면 기존 값이 변경되는 것이 아니라 새로운 메모리 공간을 확보하여 새 값을 저장하고, 변수는 새로운 메모리 공간을 참조하는 것

>가비지 콜렉터 : 
애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능으로, 자바스크립트는 이를 내장하고 있어 메모리 누수를 방지한다.

## 4-7. 식별자 네이밀 규칙

**식별자 네이밍 규칙:**

1. **특수문자 제한** - 문자, 숫자, 언더스코어(_), 달러 기호($)만 포함 가능
2. **첫 글자 제한** - 숫자로 시작할 수 없음 (문자, _, $로만 시작)
3. **예약어 금지** - `var`, `function`, `if` 등 자바스크립트 예약어 사용 불가
4. **대소문자 구분** - `name`과 `Name`은 다른 식별자

**권장 네이밍 컨벤션:**

- **카멜케이스**: 변수, 함수명 (`firstName`, `getUserInfo`)
- **파스칼케이스**: 생성자 함수, 클래스명 (`User`, `StudentInfo`)
- **스네이크케이스**: 상수 (`MAX_COUNT`, `API_URL`)

**좋은 예:**

```javascript
const userName = 'John';    // 카멜케이스
const MAX_SIZE = 100;       // 상수
function getUserData() {}   // 동사+명사
```

![alt text](/04_Assets/image-7.png)


---


# 05 표현식과 문

## 5-1. 값

값value은 식(표현식expression)이 평가(evaluate) 되어 생성된 결과

> 평가 : 
>식을 해석해서 값을 생성하거나 참조하는 것을 의미

## 5-2. 리터럴

약속된 기호로 값을 생성하는 표기법

![alt text](/04_Assets/image-8.png)

## 5-3. 표현식

값으로 평가될 수 있는 문(statement)

표현식이 평가되면 새로운 값을 생성 또는 기존 값 참조 한다. 

![alt text](/04_Assets/image-9.png)

## 5-4. 문

프로그램을 구성하는 기본 단위이자 최소 실행 단위

> 프로그램 : 
>문의 집합으로 이뤄진 것

> 프로그래밍 : 
>문을 작성하고 순서에 맞게 나열하는 것

![alt text](/04_Assets/image-10.png)

## 5-5. 세미콜론과 세미콜론 자동 삽입 기능

0개 이상의 문을 중 괄호로 묶은 코드 블록({ ... }) 뒤에는 세미콜론을 붙이지 않는다.
(예: if 문, for 문, 함수 등) - 자체 종결성(self closing)을 갖기 때문

## 5-6. 표현식인 문과 표현식이 아닌 문

변수에 할당해 보면
표현 식인 문은 값으로 평가되므로 변수에 할당 가능
표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러 발생


---


# 06 데이터 타입

![alt text](/04_Assets/image-11.png)

## 6-1. 숫자 타입

모든 수를 실수로 처리한다. 
```js
// 모두 숫자 타입
var integer = 10; // 정수
var double = 10.12; // 실수
var negative =-20; // 음의 정수
```

```js
// 숫자 타입은 모두 실수로 처리
console.log (1 === 1.0); // true
```

## 6-2. 문자열 타입

```js
// 문자열 타입
var string;
string = '문자열'; // 작은따옴표 (자바스크립트 일반적 표기법)
string = "문자열"; // 큰따옴표
string = `문자열` ; // 백틱(ES6)
```

## 6-3. 템플릿 리터럴

멀티라인 문자열(multi-line string)
표현식 삽입(expression interpolation)
태그드 템플릿(tagged template) 등 편리한 문자열 처리 기능 제공

```js
var template = `Template literal` ;
console.log(template); // Template literal
```

### 6-3-1. 멀티라인 문자열

문자열 줄바꿈은 백슬래시(\)로 시작하는 이스케이프 시퀀스(escape sequence) 사용해야 한다.

![alt text](/04_Assets/image-12.png)

```js
var template = '‹ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
console.log(template);
```

```html
<!-- 출력 결과 -->
<ul>
	<li>
		<a href="#">Home</a>
	</li>
</ul>
```

### 6-3-2. 표현식 삽입

```js
var first = 'Ung-mo';
var last = 'Lee';

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.'); // My name is Ung-mo Lee.
```


```js
var first = 'Ung-mo';
var last = 'Lee';

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.
```

표현식을 삽입하려면 ${ }으로 표현식을 감싼다. 
표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입


```js
console.log(`1 + 2 = ${1 + 2}`); // 1+ 2 = 3
```

표현식 삽입은 반드시 템플릿 리터럴 내에서 사용

```js
console.log('1 + 2 =${1 + 2}'); // 1 + 2=$11 + 2}
```

## 6-4. 불리언 타입

논리적 참 거짓 나타낸다. 

조건문에서 자주 사용

## 6-5. undefined 타입

변수를 선언한 이후 값을 할당하지 않은 변수 참조 하면 undefined 반환

## 6-6. null 타입

## 6-7. 심벌 타입

변경 불가능한 원시 타입을 값

다른 값과 중복되지 않는 유일무이한 값

이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용

```js
// 심벌 값 생성
var key = Symbol ( 'key');
console.log(typeof key); // symbol

// 객체 생성
var obj = 1};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console. log(obj[key]); // value
```

## 6-8. 객체 타입

자바스크립트는 객체 기반 언어이다. 

## 6-9. 데이터 타입의 필요성

### 6-9-1. 데이터 타입에 의한 메모리 공간의 확보와 참조

몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있 는지 알아야 한다.

```js
var score = 100;
```

위 코드 실행
(컴퓨터) 100을 저장하기 위한 메모리 공간 확보
확보된 메모리에 숫자 100을 2진수로 저장

메모리 공간의 크기를 알아야 한다. 
변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기 결정

### 6-9-2. 데이터 타입에 의한 값의 해석

메모리에 읽어드린 2진수 해석

모든 값은 데이터 타입을 가지며, 메모리에 비트의 나열(2진수)로 저장
메모리에 저장된 값은 데이터 타입에 따라 다르게 해석
(예: 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 'A'다.)


데이터 타입이 필요한 이유 : 
- ﻿﻿값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- ﻿﻿값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- ﻿﻿메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 6-10. 동적 타이핑

### 6-10-1. 동적 타입 언어와 정적 타입 언어

typeof 연산자는 연산자 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다. 

```js
var foo;
console.log(typeof foo); // undefined

foo = 3;
console.log(typeof foo); // number

foo = 'Hello';
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // boolean

foo = null;
console.log(typeof foo); // object

foo = Symbol();
console. log(typeof foo); // symbol

foo = {}; // 객체
console.log(typeof foo); // object

foo = []; // 배열
console.log(typeof foo); // object

foo = function () {}; // 함수
console.log(typeof foo); // function
```

자바스크립트는 변수의 타입이 할당 시점에 결정되고
재할당으로 언제든 변경될 수 있는 동적 타이핑 특징을 가진 동적 타입 언어이다. 

### 6-10-2. 동적 타입 언어와 변수

모든 소프트웨어 아키텍처에서 트레이드 오프가 존재하며
동적 타입 언어는 편리하지만 완벽한 해결책은 아니다.


---


# 07 연산자

## 7-1. 산술 연산자

### 7-1-1. 이항 산술 연산자

2개의 피연산자를 산술 연산

피연산자의 값이 바뀌는 경우가 없고, 항상 새로운 값을 만든다. 

```js
5+ 2; // 7
5 - 2; // 3
5 * 2; // 10
5 / 2; // 2.5
5 % 2; // 1
```

### 7-1-2. 단항 산술 연산자

1개의 피연산자를 산술연산하여 숫자 값을 만든다. 

![alt text](/04_Assets/image.png)

++/--
전위 증가/감소 연산자
먼저 피연산자의 값을 증가/감소 시킨 후 다른 연산자 수행

```js
var x = 5, result;

// 선할당 후증가(postfix increment operator)
result = x++;
console. log(result, x); // 5 6

// 선증가 후할당(prefix increment operator)
result = ++x;
console.log(result, x); // 77

// 선할당 후감소(postfix decrement operator)
result = X--;
console.log(result, x); // 7 6

// 선감소 후할당(prefix decrement operator)
result = --x;
console.log(result, x); // 5 5
```

```js
var x = '1';

// 문자열을 숫자로 타입 변환한다.
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // "1"

// 불리언 값을 숫자로 타입 변환한다.
x = true;
console.log(+x); // 1
// 부수 효과는 없다.
console.log(x); // true

// 불리언 값을 숫자로 타입 변환한다.
x = false;
console.log(+x); // 0
// 부수 효과는 없다.
console.log(x); // false

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.
x = 'Hello' ;
console.log(+x); // NaN
// 부수 효과는 없다.
console. log(x); // "Hello"
```

### 7-1-3. 문자열 연결 연산자

+연산자는 피연산자 중 하나 이상의 문자열인 경우 연결 연산자로 동작

```js
// 문자열 연결 연산자
'1' + 2; // '12'
1 + '2'; // '12'

// 산술 연산자
1 + 2; // 3

// true는 1로 타입 변환된다.
1 + true; // 2

// false는 0으로 타입 변환된다.
1 + false; // 1

// null은 0으로 타입 변환된다.
1 + null; // 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined; // NaN
1 + undefined; // NaN
```

## 7-2. 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당

```js
var x;
x = 10;
console.log(x); // 10

x += 5; // x = x + 5;
console.log(x); // 15

x -= 5; // x = x - 5;
console.log(x); // 10

x *= 5; // x = x * 5;
console.log(x); // 50

x /= 5; // x = x / 5;
console.log(x); // 10

x %= 5; // x = x % 5;
console.log(x); // 0

var str = 'My name is ';

// 문자열 연결 연산자
str += 'Lee'; // str = str + 'Lee';
console.log(str); // 'My name is Lee'
```

## 7-3. 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환

if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용

### 7-3-1. 동등/일치 비교 연산자

좌항과 우항의 피연산자가 같은 값으로 평가되는 지 비교해 불리언 값을 반환

비교 연산자 - 느슨한 비교
일치 비교 연산자 - 엄격한 비교

![alt text](/04_Assets/image-13.png)

동등 비교 연산자 ==
좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시 킨 후 같은 값인지 비교

```js
// 동등 비교
5 == 5; // true

// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.
5 == '5'; // true
```

연산자는 예측하기 어려운 결과를 만들어낸다. 따라서 동등 비교 연산자는 사용하지 않는 편이 좋다.

일치 비교 연산자에서 NaN을 주의

```js
// NaN은 자신과 일치하지 않는 유일한 값이다.
NaN === NaN; // false
```

숫자가 NaN인지 조사하려면 빌트인 함수 Number. isNaN 을 사용한다.

```js
// Number. isNaN 함수는 지정한 값이 NaN인지 확인하고 그 결과를 불리언 값으로 반환한다.
Number. isNaN(NaN); // true
Number. isNaN(10); // false
Number. isNaN(1 + undefined); // true
```

일치 비교 연산자에서 0을 주의

자바스크립트에는 양의 0과 음의 0이 있는데 이들을 비교하면 true를 반환한다. 

```js
// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 결과는 true다.
0 === -0; // true
0 == -0; // true
```

```js
-0 === +0; // true
Object.is(-0, +0); // false

NaN === NaN; // false
Object.is(NaN, NaN); // true
```

### 7-3-2. 대소 관계 비교 연산자

## 7-4. 삼항 조건 연산자

![alt text](/04_Assets/image-14.png)

## 7-5. 논리 연산자

드 모르간의 법칙
복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환

```js
!(x || y) === (!x && !y)
!(x && y) === (!x || !y)
```

## 7-6. 쉼표 연산자

왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지 막 피연산자의 평가 결과 반환

```js
var x, y, z;
x = 1, y = 2, z = 3; // 3
```

## 7-7. 그룹 연산자

소괄호()로 피연산자를 감싸는 그룹 연산자

연산자의 우선순위를 조절 가능 (가장 높은 우선순위)

## 7-8. typeof 연산자

데이터 타입을 문자열로 반환

```js
typeof "";           // "string"
typeof 1;            // "number"
typeof NaN;          // "number"
typeof true;         // "boolean"
typeof undefined;    // "undefined"
typeof Symbol();     // "symbol"
typeof null;         // "object"      // JS 설계상의 버그로 알려진 결과
typeof [];           // "object"      // 배열도 객체 타입
typeof {};           // "object"
typeof new Date();   // "object"
typeof /test/gi;     // "object"      // 정규 표현식도 객체
typeof function() {}; // "function"
```

```js
typeof null;         // "object" 
```
자바 스크립트의 첫 번째 버전의 버그다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다.

값이 nuLL 타입인지 확인할 때 일치 연산자== 를 사용하기

```js
var foo = null;

typeof foo === null; // false 
foo === null; // true
```

## 7-9. 지수 연산자

```js
2 ** 2;     // 4
2 ** 2.5;   // 5.65685424949238
2 ** 0;     // 1
2 ** -2;    // 0.25
```

지수 연산자가 도입되기 이전에는 Math.pow 메서드 사용

```js
Math.pow(2, 2);     // 4
Math.pow(2, 2.5);   // 5.65685424949238
Math.pow(2, 0);     // 1
Math.pow(2, -2);    // 0.25
```

지수 연산자가 Math.pow 메서드 보다 가독성이 좋은 경우

```js
// 지수 연산자의 결합 순서는 우항에서 좌항이다. 즉, 우결합성을 갖는다.
2 ** (3 ** 2); // 512
Math. pow(2, Math. pow(3, 2)); // 512
```

![alt text](/04_Assets/image-15.png)

## 7-10. 그 외의 연산자

![alt text](/04_Assets/image-16.png)

## 7-11. 연산자의 부수 효과

## 7-12. 연산자 우선순위

![alt text](/04_Assets/image-17.png)